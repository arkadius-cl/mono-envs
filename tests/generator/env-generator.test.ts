import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { EnvGenerator } from '../../src/generator/env-generator';
import { AppManager } from '../../src/detection/app-manager';
import { AppInfo, MonorepoInfo } from '../../src/types';

describe('EnvGenerator', () => {
  let tempDir: string;
  let mockApps: AppInfo[];
  let mockMonorepoInfo: MonorepoInfo;
  let appManager: AppManager;
  let envGenerator: EnvGenerator;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'env-generator-test-'));

    mockApps = [
      {
        name: '@test/app1',
        path: path.join(tempDir, 'apps/app1'),
        type: 'app',
        envPath: path.join(tempDir, 'apps/app1/.env')
      },
      {
        name: '@test/app2',
        path: path.join(tempDir, 'apps/app2'),
        type: 'app',
        envPath: path.join(tempDir, 'apps/app2/.env')
      },
      {
        name: '@test/convex',
        path: path.join(tempDir, 'apps/convex'),
        type: 'convex',
        envPath: path.join(tempDir, 'apps/convex/.env')
      }
    ];

    mockMonorepoInfo = {
      type: 'pnpm',
      root: tempDir,
      apps: mockApps,
      configPath: path.join(tempDir, 'env.config.json')
    };

    appManager = new AppManager(mockMonorepoInfo);
    envGenerator = new EnvGenerator(appManager);

    // Create app directories
    mockApps.forEach(app => {
      fs.mkdirSync(app.path, { recursive: true });
    });
  });

  afterEach(() => {
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  describe('generate', () => {
    const mockConfig = {
      version: '1.0.0',
      variables: [
        {
          name: 'API_KEY',
          value: 'test-api-key',
          apps: ['@test/app1', '@test/app2']
        },
        {
          name: 'DATABASE_URL',
          value: 'postgres://localhost',
          apps: ['*']
        },
        {
          name: 'CONVEX_URL',
          value: 'https://convex.dev',
          apps: ['@test/convex']
        }
      ]
    };

    it('should generate .env files for all apps', () => {
      const result = envGenerator.generate(mockConfig);

      expect(result.success).toBe(true);
      expect(result.generated).toHaveLength(3);
      expect(result.generated).toContain('@test/app1');
      expect(result.generated).toContain('@test/app2');
      expect(result.generated).toContain('@test/convex');
      expect(result.errors).toHaveLength(0);
    });

    it('should generate correct content for each app', () => {
      envGenerator.generate(mockConfig);

      const app1Env = fs.readFileSync(mockApps[0].envPath, 'utf-8');
      const app2Env = fs.readFileSync(mockApps[1].envPath, 'utf-8');
      const convexEnv = fs.readFileSync(mockApps[2].envPath, 'utf-8');

      expect(app1Env).toContain('API_KEY=test-api-key');
      expect(app1Env).toContain('DATABASE_URL=postgres://localhost');
      expect(app1Env).not.toContain('CONVEX_URL');

      expect(app2Env).toContain('API_KEY=test-api-key');
      expect(app2Env).toContain('DATABASE_URL=postgres://localhost');
      expect(app2Env).not.toContain('CONVEX_URL');

      expect(convexEnv).not.toContain('API_KEY');
      expect(convexEnv).toContain('DATABASE_URL=postgres://localhost');
      expect(convexEnv).toContain('CONVEX_URL=https://convex.dev');
    });

    it('should include header with app name and timestamp', () => {
      envGenerator.generate(mockConfig);

      const app1Env = fs.readFileSync(mockApps[0].envPath, 'utf-8');
      expect(app1Env).toContain('# Auto-generated by monorepo-env-manager');
      expect(app1Env).toContain(`# App: ${mockApps[0].name}`);
      expect(app1Env).toContain('# Generated at:');
    });

    it('should handle dry run option', () => {
      const result = envGenerator.generate(mockConfig, { dryRun: true });

      expect(result.generated).toHaveLength(0);
      expect(result.skipped).toHaveLength(3);
      expect(result.skipped).toContain('@test/app1');

      mockApps.forEach(app => {
        expect(fs.existsSync(app.envPath)).toBe(false);
      });
    });

    it('should filter apps when filterApps option is provided', () => {
      const result = envGenerator.generate(mockConfig, {
        filterApps: ['@test/app1']
      });

      expect(result.generated).toHaveLength(1);
      expect(result.generated).toContain('@test/app1');
      expect(fs.existsSync(mockApps[0].envPath)).toBe(true);
      expect(fs.existsSync(mockApps[1].envPath)).toBe(false);
    });

    it('should handle write errors', () => {
      // Create a file where directory is expected to cause write error
      const invalidPath = path.join(tempDir, 'apps', 'invalid-app', '.env');
      fs.mkdirSync(path.dirname(invalidPath), { recursive: true });
      fs.writeFileSync(invalidPath, 'content');
      
      // Create an app with invalid env path (pointing to a file instead of directory)
      const invalidApp = {
        name: '@test/invalid-app',
        path: path.join(tempDir, 'apps', 'invalid-app'),
        type: 'app' as const,
        envPath: path.join(tempDir, 'apps', 'nonexistent-dir', '.env')
      };

      const monorepoInfoWithInvalid: MonorepoInfo = {
        type: 'pnpm',
        root: tempDir,
        apps: [...mockApps, invalidApp],
        configPath: path.join(tempDir, 'config.json')
      };
      const appManagerWithInvalid = new AppManager(monorepoInfoWithInvalid);
      const envGeneratorWithInvalid = new EnvGenerator(appManagerWithInvalid);

      const config = {
        version: '1.0.0',
        variables: [
          {
            name: 'TEST_VAR',
            value: 'test',
            apps: ['@test/invalid-app']
          }
        ]
      };

      const result = envGeneratorWithInvalid.generate(config);
      expect(result.success).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0].app).toBe('@test/invalid-app');
    });

    it('should include description comments when provided', () => {
      const configWithDescriptions = {
        version: '1.0.0',
        variables: [
          {
            name: 'API_KEY',
            value: 'test-key',
            apps: ['@test/app1'],
            description: 'API key for external service'
          }
        ]
      };

      envGenerator.generate(configWithDescriptions);
      const app1Env = fs.readFileSync(mockApps[0].envPath, 'utf-8');

      expect(app1Env).toContain('API_KEY=test-key # API key for external service');
    });

    it('should use default value when value is undefined', () => {
      const configWithDefault = {
        version: '1.0.0',
        variables: [
          {
            name: 'PORT',
            default: '3000',
            apps: ['@test/app1']
          }
        ]
      };

      envGenerator.generate(configWithDefault);
      const app1Env = fs.readFileSync(mockApps[0].envPath, 'utf-8');

      expect(app1Env).toContain('PORT=3000');
    });

    it('should set empty string for required variables without value', () => {
      const configWithRequired = {
        version: '1.0.0',
        variables: [
          {
            name: 'SECRET_KEY',
            required: true,
            apps: ['@test/app1']
          }
        ]
      };

      envGenerator.generate(configWithRequired);
      const app1Env = fs.readFileSync(mockApps[0].envPath, 'utf-8');

      expect(app1Env).toContain('SECRET_KEY=');
    });
  });

  describe('validateConfig', () => {
    it('should validate config with valid app names', () => {
      const validConfig = {
        version: '1.0.0',
        variables: [
          {
            name: 'API_KEY',
            value: 'test',
            apps: ['@test/app1', '@test/app2']
          }
        ]
      };

      const result = envGenerator.validateConfig(validConfig);
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should detect unknown app names', () => {
      const invalidConfig = {
        version: '1.0.0',
        variables: [
          {
            name: 'API_KEY',
            value: 'test',
            apps: ['@test/nonexistent']
          }
        ]
      };

      const result = envGenerator.validateConfig(invalidConfig);
      expect(result.valid).toBe(false);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0]).toContain('@test/nonexistent');
    });

    it('should allow wildcard (*) for all apps', () => {
      const configWithWildcard = {
        version: '1.0.0',
        variables: [
          {
            name: 'API_KEY',
            value: 'test',
            apps: ['*']
          }
        ]
      };

      const result = envGenerator.validateConfig(configWithWildcard);
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should detect required variables without value or default', () => {
      const invalidConfig = {
        version: '1.0.0',
        variables: [
          {
            name: 'SECRET_KEY',
            required: true,
            apps: ['@test/app1']
          }
        ]
      };

      const result = envGenerator.validateConfig(invalidConfig);
      expect(result.valid).toBe(false);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0]).toContain('SECRET_KEY');
      expect(result.errors[0]).toContain('required');
    });

    it('should pass validation for required variable with default', () => {
      const validConfig = {
        version: '1.0.0',
        variables: [
          {
            name: 'PORT',
            required: true,
            default: '3000',
            apps: ['@test/app1']
          }
        ]
      };

      const result = envGenerator.validateConfig(validConfig);
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should report multiple errors', () => {
      const invalidConfig = {
        version: '1.0.0',
        variables: [
          {
            name: 'API_KEY',
            value: 'test',
            apps: ['@test/nonexistent1']
          },
          {
            name: 'SECRET_KEY',
            required: true,
            apps: ['@test/app1']
          }
        ]
      };

      const result = envGenerator.validateConfig(invalidConfig);
      expect(result.valid).toBe(false);
      expect(result.errors).toHaveLength(2);
    });
  });

  describe('preview', () => {
    const mockConfig = {
      version: '1.0.0',
      variables: [
        {
          name: 'API_KEY',
          value: 'test-key',
          apps: ['@test/app1']
        }
      ]
    };

    it('should return env content for specified app', () => {
      const preview = envGenerator.preview(mockConfig, '@test/app1');

      expect(preview).toContain('API_KEY=test-key');
      expect(preview).toContain('# Auto-generated by monorepo-env-manager');
      expect(preview).toContain(`# App: ${mockApps[0].name}`);
    });

    it('should throw error for nonexistent app', () => {
      expect(() => {
        envGenerator.preview(mockConfig, '@test/nonexistent');
      }).toThrow('App "@test/nonexistent" not found');
    });

    it('should not write file when previewing', () => {
      envGenerator.preview(mockConfig, '@test/app1');
      expect(fs.existsSync(mockApps[0].envPath)).toBe(false);
    });
  });
});