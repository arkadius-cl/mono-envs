import * as fs from 'fs';
import { MonorepoEnvConfig, AppInfo, GeneratorOptions } from '../types';
import { AppManager } from '../detection/app-manager';

export interface GenerateResult {
  success: boolean;
  generated: string[];
  skipped: string[];
  errors: { app: string; error: string }[];
}

export class EnvGenerator {
  private appManager: AppManager;

  constructor(appManager: AppManager) {
    this.appManager = appManager;
  }

  generate(config: MonorepoEnvConfig, options: GeneratorOptions = {}): GenerateResult {
    const result: GenerateResult = {
      success: true,
      generated: [],
      skipped: [],
      errors: []
    };

    const appsToProcess = options.filterApps
      ? this.appManager.getAppsByNames(options.filterApps)
      : this.appManager.getAllApps();

    for (const app of appsToProcess) {
      try {
        const envContent = this.generateEnvForApp(config, app.name);
        
        if (options.dryRun) {
          result.skipped.push(app.name);
          if (options.verbose) {
            console.log(`[DRY RUN] Would generate .env for ${app.name}`);
          }
          continue;
        }

        if (options.verbose) {
          console.log(`Generating .env for ${app.name}`);
        }

        fs.writeFileSync(app.envPath, envContent, 'utf-8');
        result.generated.push(app.name);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        result.errors.push({ app: app.name, error: errorMessage });
        result.success = false;
      }
    }

    return result;
  }

  private generateEnvForApp(config: MonorepoEnvConfig, appName: string): string {
    const variables = config.variables.filter(variable => 
      variable.apps.includes('*') || variable.apps.includes(appName)
    );

    const lines: string[] = [];
    lines.push(`# Auto-generated by monorepo-env-manager`);
    lines.push(`# App: ${appName}`);
    lines.push(`# Generated at: ${new Date().toISOString()}`);
    lines.push('');

    for (const variable of variables) {
      const value = this.resolveVariableValue(variable);
      const comment = variable.description ? ` # ${variable.description}` : '';
      lines.push(`${variable.name}=${value}${comment}`);
    }

    return lines.join('\n');
  }

  private resolveVariableValue(variable: any): string {
    if (variable.value !== undefined) {
      return String(variable.value);
    }

    if (variable.default !== undefined) {
      return String(variable.default);
    }

    if (variable.required) {
      return '';
    }

    return '';
  }

  validateConfig(config: MonorepoEnvConfig): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    const allApps = new Set(this.appManager.getAllApps().map(app => app.name));

    for (const variable of config.variables) {
      for (const appName of variable.apps) {
        if (appName !== '*' && !allApps.has(appName)) {
          errors.push(`Variable "${variable.name}" references unknown app "${appName}"`);
        }
      }

      if (variable.required && !variable.value && variable.default === undefined) {
        errors.push(`Variable "${variable.name}" is required but has no value or default`);
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  preview(config: MonorepoEnvConfig, appName: string): string {
    const app = this.appManager.getAppByName(appName);
    
    if (!app) {
      throw new Error(`App "${appName}" not found`);
    }

    return this.generateEnvForApp(config, appName);
  }
}
